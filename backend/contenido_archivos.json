{
  "src\\app.ts": "import express from \"express\";\r\nimport dashboardRoutes from \"@/interfaces/routes/dashboard/dashboard.routes\";\r\nimport authRoutes from \"@/interfaces/routes/auth/auth.routes\";\r\nimport cors from \"cors\";\r\nimport notFound from \"@/interfaces/middlewares/error/notFound.middleware\";\r\nimport errorHandler from \"@/interfaces/middlewares/error/errorHandler.middleware\";\r\nimport { sanitizeRequest } from \"@/interfaces/middlewares/sanitize/sanitizeRequest\";\r\nimport helmet from \"helmet\";\r\n\r\nconst app = express();\r\napp.use(express.json({ limit: \"10kb\" })); // Evita ataques de payloads masivos (DoS)\r\napp.use(\r\n  helmet.hsts({\r\n    maxAge: 60 * 60 * 24 * 365, // 1 a√±o\r\n    includeSubDomains: true,\r\n  })\r\n); // üîí Agrega cabeceras de seguridad\r\napp.use(\r\n  cors({\r\n    origin: \"http://localhost:5173\", // üëà Aseg√∫rate que coincida con el frontend\r\n    credentials: true,\r\n  })\r\n);\r\napp.use(sanitizeRequest);\r\n\r\n// Agrupar rutas protegidas bajo /api\r\napp.use(\"/api\", dashboardRoutes);\r\napp.use(\"/api\", authRoutes);\r\napp.use(notFound); // üëâ Para rutas no encontradas\r\napp.use(errorHandler); // üëâ Para manejar errores de forma centralizada\r\n\r\nexport default app;\r\n",
  "src\\config\\db.ts": "// db.ts\r\nimport mysql from 'mysql2/promise';\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\n\r\nexport const db = mysql.createPool({\r\n  host: process.env.DB_HOST || 'localhost',\r\n  user: process.env.DB_USER || 'root',\r\n  password: process.env.DB_PASSWORD || '',\r\n  database: process.env.DB_NAME || 'aqua_river_park',\r\n  waitForConnections: true,\r\n  connectionLimit: 10,\r\n  queueLimit: 0\r\n});\r\n\r\n// console.log('Conectando a la DB con usuario:', process.env.DB_USER);\r\n// console.log('Contrase√±a:', process.env.DB_PASSWORD);\r\n\r\n\r\n\r\nexport default db;\r\n",
  "src\\config\\mailer.ts": "// backend/config/mailer.ts\r\nimport dotenv from 'dotenv';\r\ndotenv.config();\r\nimport nodemailer from 'nodemailer';\r\n\r\nexport const transporter = nodemailer.createTransport({\r\n  host: process.env.MAIL_HOST,\r\n  port: Number(process.env.MAIL_PORT),\r\n  auth: {\r\n    user: process.env.MAIL_USER,\r\n    pass: process.env.MAIL_PASS\r\n  }\r\n});\r\n",
  "src\\domain\\models\\user\\cart.model.ts": "export interface Cart {\r\n    id: number;\r\n    user_id?: number | null;\r\n    created_at?: Date;\r\n  }\r\n  ",
  "src\\domain\\models\\user\\cartItem.model.ts": "export interface CartItem {\r\n    id: number;\r\n    cart_id?: number | null;\r\n    service_id?: number | null;\r\n    quantity: number;\r\n  }\r\n  ",
  "src\\domain\\models\\user\\permission.model.ts": "export interface Permission {\r\n    id: number;\r\n    name: string;\r\n  }\r\n  ",
  "src\\domain\\models\\user\\role.model.ts": "export interface Role {\r\n    id: number;\r\n    name: string;\r\n  }\r\n  ",
  "src\\domain\\models\\user\\service.model.ts": "export type ServiceType = 'entrada' | 'reserva' | 'evento' | 'vip';\r\n\r\nexport interface Service {\r\n  id: number;\r\n  title: string;\r\n  description?: string | null;\r\n  price: number;\r\n  duration?: string | null;\r\n  image_url?: string | null;\r\n  type?: ServiceType;\r\n  created_at?: Date;\r\n}\r\n",
  "src\\domain\\models\\user\\user.model.ts": "export interface User {\r\n  id: number;\r\n  name: string;\r\n  email: string;\r\n  password_hash: string;\r\n  created_at: Date;\r\n  is_confirmed?: boolean;\r\n  confirmation_token?: string | null;\r\n  confirmation_expires?: Date | null;\r\n  reset_token?: string | null;\r\n  reset_expires?: Date | null;\r\n  last_login?: Date | null;\r\n  avatar_url?: string | null;\r\n  login_attempts?: number;\r\n  locked_until?: Date | null;\r\n  role_id?: number | null;\r\n  phone?: string | null;\r\n}\r\n",
  "src\\domain\\ports\\role.repository.ts": "// src/domain/ports/role.repository.ts\r\nimport { Role } from \"@/domain/models/user/role.model\";\r\n\r\nexport interface RoleRepository {\r\n  findAllRoles(): Promise<Role[]>;\r\n  findRoleById(id: number): Promise<Role | null>;\r\n  findRoleByName(name: string): Promise<Role | null>;\r\n  createRole(role: Omit<Role, \"id\">): Promise<number>;\r\n  deleteRole(id: number): Promise<void>;\r\n}\r\n",
  "src\\domain\\ports\\user.repository.ts": "import { User } from \"@/domain/models/user/user.model\";\r\n\r\nexport interface UserRepository {\r\n  findUserByEmail(\r\n    email: string\r\n  ): Promise<(User & { role_name?: string }) | null>;\r\n  createUser(\r\n    user: Omit<\r\n      User,\r\n      | \"id\"\r\n      | \"created_at\"\r\n      | \"last_login\"\r\n      | \"avatar_url\"\r\n      | \"login_attempts\"\r\n      | \"locked_until\"\r\n    >\r\n  ): Promise<number>;\r\n  updateConfirmationToken(\r\n    email: string,\r\n    token: string,\r\n    expires: Date\r\n  ): Promise<void>;\r\n  updateResetToken(email: string, token: string, expires: Date): Promise<void>;\r\n  findUserByResetToken(\r\n    token: string\r\n  ): Promise<Pick<\r\n    User,\r\n    \"id\" | \"email\" | \"password_hash\" | \"reset_expires\"\r\n  > | null>;\r\n  updatePassword(userId: number, newPasswordHash: string): Promise<void>;\r\n  findUserByToken(token: string): Promise<User | null>;\r\n  checkConfirmedByEmail(\r\n    email: string\r\n  ): Promise<Pick<User, \"is_confirmed\"> | null>;\r\n  confirmUserById(id: number): Promise<void>;\r\n  findUserBasicByEmail(email: string): Promise<Pick<User, \"id\"> | null>;\r\n  getResetTokenExpiration(\r\n    token: string\r\n  ): Promise<Pick<User, \"reset_expires\"> | null>;\r\n}\r\n",
  "src\\domain\\services\\auth\\auth.service.ts": "// src/domain/services/auth/auth.service.ts\r\nimport bcrypt from \"bcryptjs\";\r\nimport crypto from \"crypto\";\r\nimport { generateToken } from \"@/shared/security/jwt\";\r\nimport sendConfirmationEmail from \"@/infraestructure/mail/mailerConfirmation\";\r\nimport { UserRepository } from \"@/domain/ports/user.repository\";\r\nimport {\r\n  validateEmail,\r\n  validateNewPassword,\r\n  validatePasswordChange,\r\n} from \"@/shared/validations/validators\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\n// üëá Define aqu√≠ los roles permitidos para el JWT\r\ntype RoleName = \"admin\" | \"client\";\r\n\r\nexport const registerUser = async (\r\n  deps: { userRepository: UserRepository },\r\n  {\r\n    name,\r\n    email,\r\n    password,\r\n    phone,\r\n  }: {\r\n    name: string;\r\n    email: string;\r\n    password: string;\r\n    phone: string;\r\n  }\r\n) => {\r\n  const { userRepository } = deps;\r\n  validateEmail(email);\r\n  validateNewPassword(password);\r\n\r\n  const existingUser = await userRepository.findUserByEmail(email);\r\n  if (existingUser) throw new Error(\"El correo ya est√° registrado\");\r\n\r\n  const password_hash = await bcrypt.hash(password, 10);\r\n  const confirmation_token = crypto.randomBytes(32).toString(\"hex\");\r\n  const confirmation_expires = new Date(Date.now() + 24 * 60 * 60 * 1000);\r\n\r\n  await userRepository.createUser({\r\n    name,\r\n    email,\r\n    password_hash,\r\n    phone,\r\n    role_id: 4, // üëà este n√∫mero deber√≠as mapearlo con un nombre si lo necesitas\r\n    confirmation_token,\r\n    confirmation_expires,\r\n  });\r\n\r\n  await sendConfirmationEmail(email, confirmation_token);\r\n};\r\n\r\nexport const loginUser = async (\r\n  deps: { userRepository: UserRepository },\r\n  email: string,\r\n  password: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByEmail(email);\r\n  if (!user) throw new Error(\"Correo no registrado\");\r\n\r\n  if (!user.is_confirmed) {\r\n    const tokenExpired =\r\n      !user.confirmation_token ||\r\n      !user.confirmation_expires ||\r\n      new Date(user.confirmation_expires) < new Date();\r\n\r\n    throw {\r\n      message: \"Debes confirmar tu cuenta\",\r\n      tokenExpired,\r\n    };\r\n  }\r\n\r\n  const isMatch = await bcrypt.compare(password, user.password_hash);\r\n  if (!isMatch) throw new Error(\"Contrase√±a incorrecta\");\r\n\r\n  const token = generateToken({\r\n    id: user.id,\r\n    email: user.email,\r\n    name: user.name,\r\n    role: (user.role_name || \"client\") as RoleName, // ‚Üê CORREGIDO\r\n  });\r\n\r\n  return {\r\n    token,\r\n    user: {\r\n      email: user.email,\r\n      isConfirmed: Boolean(user.is_confirmed),\r\n    },\r\n  };\r\n};\r\n\r\nexport const sendResetPassword = async (\r\n  deps: { userRepository: UserRepository },\r\n  email: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByEmail(email);\r\n  if (!user) throw new Error(\"Correo no registrado\");\r\n\r\n  const token = crypto.randomBytes(32).toString(\"hex\");\r\n  const expires = new Date(Date.now() + 60 * 60 * 1000);\r\n\r\n  await userRepository.updateResetToken(email, token, expires);\r\n  logger.info(`üìß Enlace de recuperaci√≥n enviado a ${email}`);\r\n};\r\n\r\nexport const resetPassword = async (\r\n  deps: { userRepository: UserRepository },\r\n  token: string,\r\n  newPassword: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByResetToken(token);\r\n  if (!user) throw new Error(\"Token inv√°lido o expirado\");\r\n\r\n  await validatePasswordChange(newPassword, user.email, user.password_hash);\r\n\r\n  const password_hash = await bcrypt.hash(newPassword, 10);\r\n  await userRepository.updatePassword(user.id, password_hash);\r\n};\r\n\r\nexport const checkResetToken = async (\r\n  deps: { userRepository: UserRepository },\r\n  token: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByResetToken(token);\r\n  return (\r\n    !!user &&\r\n    user.reset_expires !== null &&\r\n    user.reset_expires !== undefined &&\r\n    new Date(user.reset_expires) > new Date()\r\n  );\r\n};\r\n",
  "src\\domain\\services\\auth\\confirm.service.ts": "// src/domain/services/auth/confirm.service.ts\r\nimport crypto from \"crypto\";\r\nimport sendConfirmationEmail from \"@/infraestructure/mail/mailerConfirmation\";\r\nimport { UserRepository } from \"@/domain/ports/user.repository\";\r\n\r\nexport const confirmAccountService = async (\r\n  deps: { userRepository: UserRepository },\r\n  token: string,\r\n  email?: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByToken(token);\r\n\r\n  if (!user) {\r\n    if (email) {\r\n      const userFromEmail = await userRepository.findUserByEmail(email);\r\n      if (userFromEmail?.is_confirmed === true) {\r\n        return { code: 200, message: \"La cuenta ya ha sido confirmada.\" };\r\n      }\r\n    }\r\n    return { code: 400, message: \"Token inv√°lido o expirado\" };\r\n  }\r\n\r\n  if (user.is_confirmed === true) {\r\n    return { code: 200, message: \"La cuenta ya ha sido confirmada.\" };\r\n  }\r\n\r\n  if (!user.confirmation_expires || new Date(user.confirmation_expires) < new Date()) {\r\n    return { code: 400, message: \"Token inv√°lido o expirado\" };\r\n  }\r\n\r\n  await userRepository.confirmUserById(user.id);\r\n  return { code: 200, message: \"Cuenta confirmada exitosamente.\" };\r\n};\r\n\r\nexport const resendConfirmationService = async (\r\n  deps: { userRepository: UserRepository },\r\n  email: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByEmail(email);\r\n  if (!user) throw new Error(\"Correo no encontrado\");\r\n  if (user.is_confirmed === true) throw new Error(\"La cuenta ya est√° confirmada\");\r\n\r\n  const token = crypto.randomBytes(32).toString(\"hex\");\r\n  const expires = new Date(Date.now() + 24 * 60 * 60 * 1000);\r\n\r\n  await userRepository.updateConfirmationToken(email, token, expires);\r\n  await sendConfirmationEmail(email, token);\r\n};\r\n",
  "src\\domain\\services\\auth\\recovery.service.ts": "import crypto from \"crypto\";\r\nimport bcrypt from \"bcryptjs\";\r\nimport sendRecoveryEmail from \"@/infraestructure/mail/mailerRecovery\";\r\nimport { UserRepository } from \"@/domain/ports/user.repository\";\r\nimport { validatePasswordChange } from \"@/shared/validations/validators\";\r\n\r\n/**\r\n * ‚úÖ Enviar enlace de recuperaci√≥n por correo\r\n */\r\nexport const sendRecoveryService = async (\r\n  deps: { userRepository: UserRepository },\r\n  email: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserBasicByEmail(email);\r\n  if (!user) throw new Error(\"Correo no registrado\");\r\n\r\n  const token = crypto.randomBytes(32).toString(\"hex\");\r\n  const expires = new Date(Date.now() + 60 * 60 * 1000); // 1 hora\r\n\r\n  await userRepository.updateResetToken(email, token, expires);\r\n  await sendRecoveryEmail(email, token);\r\n};\r\n\r\n/**\r\n * ‚úÖ Verificar validez de token de recuperaci√≥n\r\n */\r\nexport const checkTokenStatusService = async (\r\n  deps: { userRepository: UserRepository },\r\n  token: string\r\n): Promise<boolean> => {\r\n  const { userRepository } = deps;\r\n  const resetData = await userRepository.getResetTokenExpiration(token);\r\n  return !!resetData?.reset_expires && new Date(resetData.reset_expires) > new Date();\r\n};\r\n\r\n/**\r\n * ‚úÖ Cambiar contrase√±a mediante token v√°lido\r\n */\r\nexport const resetPasswordService = async (\r\n  deps: { userRepository: UserRepository },\r\n  token: string,\r\n  newPassword: string\r\n) => {\r\n  const { userRepository } = deps;\r\n  const user = await userRepository.findUserByResetToken(token);\r\n  if (!user) throw new Error(\"Token inv√°lido o expirado\");\r\n\r\n  // Validar que no sea la misma contrase√±a ni igual al correo (reglas fuertes)\r\n  await validatePasswordChange(newPassword, user.email, user.password_hash);\r\n\r\n  const password_hash = await bcrypt.hash(newPassword, 10);\r\n  await userRepository.updatePassword(user.id, password_hash);\r\n};\r\n",
  "src\\index.ts": "// index.ts\r\nimport app from \"@/app\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\nconst PORT = process.env.PORT || 3000;\r\n\r\napp.listen(PORT, () => {\r\n  logger.info(`‚úÖ Servidor iniciado en http://localhost:${PORT}`);\r\n});\r\n",
  "src\\infraestructure\\db\\role.repository.ts": "import { db } from \"@/config/db\";\r\nimport { RowDataPacket, ResultSetHeader } from \"mysql2\";\r\nimport { Role } from \"@/domain/models/user/role.model\";\r\nimport { RoleRepository } from \"@/domain/ports/role.repository\";\r\n\r\nexport const roleRepository: RoleRepository = {\r\n  async findAllRoles(): Promise<Role[]> {\r\n    const [rows] = await db.query<RowDataPacket[]>(\"SELECT * FROM roles\");\r\n    return rows as unknown as Role[];\r\n  },\r\n\r\n  async findRoleById(id: number): Promise<Role | null> {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      \"SELECT * FROM roles WHERE id = ?\",\r\n      [id]\r\n    );\r\n    return (rows[0] as Role) || null;\r\n  },\r\n\r\n  async findRoleByName(name: string): Promise<Role | null> {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      \"SELECT * FROM roles WHERE name = ?\",\r\n      [name]\r\n    );\r\n    return (rows[0] as Role) || null;\r\n  },\r\n\r\n  async createRole(role: Omit<Role, \"id\">): Promise<number> {\r\n    const [result] = await db.query<ResultSetHeader>(\r\n      \"INSERT INTO roles (name) VALUES (?)\",\r\n      [role.name]\r\n    );\r\n    return result.insertId;\r\n  },\r\n\r\n  async deleteRole(id: number): Promise<void> {\r\n    await db.query(\"DELETE FROM roles WHERE id = ?\", [id]);\r\n  },\r\n};\r\n",
  "src\\infraestructure\\db\\user.repository.ts": "import db from \"@/config/db\";\r\nimport { RowDataPacket, ResultSetHeader } from \"mysql2\";\r\nimport { User } from \"@/domain/models/user/user.model\";\r\nimport { UserRepository } from \"@/domain/ports/user.repository\";\r\n\r\nexport const userRepository: UserRepository = {\r\n  async findUserByEmail(email) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT u.*, r.name as role_name \r\n       FROM users u \r\n       LEFT JOIN roles r ON u.role_id = r.id \r\n       WHERE u.email = ?`,\r\n      [email]\r\n    );\r\n    return (rows[0] as User & { role_name?: string }) || null;\r\n  },\r\n\r\n  async createUser(user) {\r\n    const {\r\n      name,\r\n      email,\r\n      password_hash,\r\n      phone,\r\n      role_id,\r\n      confirmation_token,\r\n      confirmation_expires,\r\n    } = user;\r\n\r\n    const [result] = await db.query<ResultSetHeader>(\r\n      `INSERT INTO users (name, email, password_hash, phone, role_id, confirmation_token, confirmation_expires)\r\n       VALUES (?, ?, ?, ?, ?, ?, ?)`,\r\n      [\r\n        name,\r\n        email,\r\n        password_hash,\r\n        phone,\r\n        role_id,\r\n        confirmation_token,\r\n        confirmation_expires,\r\n      ]\r\n    );\r\n\r\n    return result.insertId;\r\n  },\r\n\r\n  async updateConfirmationToken(email, token, expires) {\r\n    await db.query(\r\n      `UPDATE users SET confirmation_token = ?, confirmation_expires = ? WHERE email = ?`,\r\n      [token, expires, email]\r\n    );\r\n  },\r\n\r\n  async updateResetToken(email, token, expires) {\r\n    await db.query(\r\n      `UPDATE users SET reset_token = ?, reset_expires = ? WHERE email = ?`,\r\n      [token, expires, email]\r\n    );\r\n  },\r\n\r\n  async findUserByResetToken(token) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT id, email, password_hash, reset_expires \r\n       FROM users \r\n       WHERE reset_token = ? AND reset_expires > NOW()`,\r\n      [token]\r\n    );\r\n    return (\r\n      (rows[0] as Pick<\r\n        User,\r\n        \"id\" | \"email\" | \"password_hash\" | \"reset_expires\"\r\n      >) || null\r\n    );\r\n  },\r\n\r\n  async updatePassword(userId, newPasswordHash) {\r\n    await db.query(\r\n      `UPDATE users SET password_hash = ?, reset_token = NULL, reset_expires = NULL WHERE id = ?`,\r\n      [newPasswordHash, userId]\r\n    );\r\n  },\r\n\r\n  async findUserByToken(token) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT * FROM users WHERE confirmation_token = ?`,\r\n      [token]\r\n    );\r\n    return (rows[0] as User) || null;\r\n  },\r\n\r\n  async checkConfirmedByEmail(email) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT is_confirmed FROM users WHERE email = ?`,\r\n      [email]\r\n    );\r\n    return (rows[0] as Pick<User, \"is_confirmed\">) || null;\r\n  },\r\n\r\n  async confirmUserById(id) {\r\n    await db.query(\r\n      `UPDATE users \r\n       SET is_confirmed = 1, confirmation_token = NULL, confirmation_expires = NULL \r\n       WHERE id = ?`,\r\n      [id]\r\n    );\r\n  },\r\n\r\n  async findUserBasicByEmail(email) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT id FROM users WHERE email = ?`,\r\n      [email]\r\n    );\r\n    return (rows[0] as Pick<User, \"id\">) || null;\r\n  },\r\n\r\n  async getResetTokenExpiration(token) {\r\n    const [rows] = await db.query<RowDataPacket[]>(\r\n      `SELECT reset_expires FROM users WHERE reset_token = ?`,\r\n      [token]\r\n    );\r\n    return (rows[0] as Pick<User, \"reset_expires\">) || null;\r\n  },\r\n};\r\n",
  "src\\infraestructure\\logger\\logger.ts": "// utils/logger.ts\r\nimport winston from \"winston\";\r\n\r\nconst logger = winston.createLogger({\r\n  level: \"info\",\r\n  transports: [\r\n    new winston.transports.Console(),\r\n    new winston.transports.File({ filename: \"logs/app.log\" }),\r\n  ],\r\n});\r\n\r\nexport default logger;\r\n",
  "src\\infraestructure\\mail\\mailerConfirmation.ts": "// backend/utils/mailerConfirmation.ts\r\nimport { transporter } from \"@/config/mailer\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\nconst sendConfirmationEmail = async (email: string, token: string) => {\r\n  const link = `${process.env.FRONTEND_URL}/confirm/${token}?email=${encodeURIComponent(email)}`;\r\n  logger.info(`üì® Enviando correo de confirmaci√≥n a ${email}`);\r\n\r\n  await transporter.sendMail({\r\n    from: '\"Aqua River Park\" <no-reply@aquariverpark.com>',\r\n    to: email,\r\n    subject: \"Confirma tu cuenta\",\r\n    html: `\r\n    <div style=\"margin: 0; padding: 0; background-color: #e0f7fa; font-family: 'Segoe UI', sans-serif;\">\r\n      <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\r\n        <tr>\r\n          <td align=\"center\" style=\"padding: 40px 10px;\">\r\n            <table cellpadding=\"0\" cellspacing=\"0\" style=\"max-width: 600px; width: 100%; background-color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); padding: 40px;\">\r\n              <tr>\r\n                <td align=\"center\" style=\"padding-bottom: 20px;\">\r\n                  <h2 style=\"font-size: 26px; color: #0ea5e9; margin: 0;\">üåä ¬°Bienvenido a Aqua River Park!</h2>\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"font-size: 16px; color: #444; text-align: center; padding-bottom: 20px;\">\r\n                   Gracias por registrarte. Estamos felices de tenerte en nuestra comunidad. Para completar tu registro, por favor confirma tu cuenta haciendo clic a continuaci√≥n.\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td align=\"center\" style=\"padding: 20px 0;\">\r\n                  <a href=\"${link}\" style=\"background-color: #0ea5e9; color: white; text-decoration: none; padding: 14px 30px; border-radius: 8px; font-size: 16px; display: inline-block;\">\r\n                    Confirmar cuenta\r\n                  </a>\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"font-size: 14px; color: #666; text-align: center; padding-top: 20px;\">\r\n                  Si no solicitaste este registro, puedes ignorar este mensaje.\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"border-top: 1px solid #eee; padding-top: 30px; text-align: center; font-size: 12px; color: #999;\">\r\n                  ¬© ${new Date().getFullYear()} Aqua River Park. Todos los derechos reservados.<br><br>\r\n                  S√≠guenos en nuestras redes sociales:\r\n                  <div style=\"margin-top: 10px;\">\r\n                    <a href=\"https://www.instagram.com/aquariverpark/\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/instagram-new.png\" alt=\"Instagram\" width=\"24\" height=\"24\" style=\"vertical-align: middle;\" />\r\n                    </a>\r\n                    <a href=\"https://www.facebook.com/aquariverpark/\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/facebook-new.png\" alt=\"Facebook\" width=\"24\" height=\"24\" style=\"vertical-align: middle;\" />\r\n                    </a>\r\n                    <a href=\"https://www.tiktok.com/@aquariverpark\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/tiktok--v1.png\" alt=\"TikTok\" width=\"24\" height=\"24\" style=\"vertical-align: middle;\" />\r\n                    </a>\r\n                    <a href=\"https://www.youtube.com/@aquariverpark\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/youtube-play.png\" alt=\"YouTube\" width=\"24\" height=\"24\" style=\"vertical-align: middle;\" />\r\n                    </a>\r\n                  </div>\r\n                </td>\r\n              </tr>\r\n            </table>\r\n          </td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n  `,\r\n  });\r\n};\r\n\r\nexport default sendConfirmationEmail;\r\n",
  "src\\infraestructure\\mail\\mailerRecovery.ts": "// backend/utils/mailerRecovery.ts\r\nimport { transporter } from \"@/config/mailer\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\nconst sendRecoveryEmail = async (email: string, token: string) => {\r\n  const link = `${process.env.FRONTEND_URL}/reset-password?token=${token}&email=${encodeURIComponent(email)}`;\r\n  logger.info(`üì® Enviando correo de confirmaci√≥n a ${email}`);\r\n\r\n  await transporter.sendMail({\r\n    from: '\"Aqua River Park\" <no-reply@aquariverpark.com>',\r\n    to: email,\r\n    subject: \"Recupera tu contrase√±a - Aqua River Park\",\r\n    html: `\r\n    <div style=\"margin: 0; padding: 0; background-color: #e0f7fa; font-family: 'Segoe UI', sans-serif;\">\r\n      <table role=\"presentation\" cellpadding=\"0\" cellspacing=\"0\" width=\"100%\">\r\n        <tr>\r\n          <td align=\"center\" style=\"padding: 40px 10px;\">\r\n            <table cellpadding=\"0\" cellspacing=\"0\" style=\"max-width: 600px; width: 100%; background-color: #ffffff; border-radius: 12px; box-shadow: 0 4px 12px rgba(0,0,0,0.1); padding: 40px;\">\r\n              <tr>\r\n                <td align=\"center\" style=\"padding-bottom: 20px;\">\r\n                  <h2 style=\"font-size: 26px; color: #0ea5e9; margin: 0;\">üîê Recuperaci√≥n de contrase√±a</h2>\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"font-size: 16px; color: #444; text-align: center; padding-bottom: 20px;\">\r\n                   Hemos recibido una solicitud para restablecer tu contrase√±a. Haz clic en el siguiente bot√≥n para continuar:\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td align=\"center\" style=\"padding: 20px 0;\">\r\n                  <a href=\"${link}\" style=\"background-color: #0ea5e9; color: white; text-decoration: none; padding: 14px 30px; border-radius: 8px; font-size: 16px; display: inline-block;\">\r\n                    Recuperar contrase√±a\r\n                  </a>\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"font-size: 14px; color: #666; text-align: center; padding-top: 20px;\">\r\n                  Si no realizaste esta solicitud, puedes ignorar este mensaje. Este enlace caduca en 1 hora.\r\n                </td>\r\n              </tr>\r\n              <tr>\r\n                <td style=\"border-top: 1px solid #eee; padding-top: 30px; text-align: center; font-size: 12px; color: #999;\">\r\n                  ¬© ${new Date().getFullYear()} Aqua River Park. Todos los derechos reservados.<br><br>\r\n                  S√≠guenos en nuestras redes sociales:\r\n                  <div style=\"margin-top: 10px;\">\r\n                    <a href=\"https://www.instagram.com/aquariverpark/\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/instagram-new.png\" alt=\"Instagram\" width=\"24\" height=\"24\" />\r\n                    </a>\r\n                    <a href=\"https://www.facebook.com/aquariverpark/\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/facebook-new.png\" alt=\"Facebook\" width=\"24\" height=\"24\" />\r\n                    </a>\r\n                    <a href=\"https://www.tiktok.com/@aquariverpark\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/tiktok--v1.png\" alt=\"TikTok\" width=\"24\" height=\"24\" />\r\n                    </a>\r\n                    <a href=\"https://www.youtube.com/@aquariverpark\" target=\"_blank\" style=\"margin: 0 10px;\">\r\n                      <img src=\"https://img.icons8.com/color/48/youtube-play.png\" alt=\"YouTube\" width=\"24\" height=\"24\" />\r\n                    </a>\r\n                  </div>\r\n                </td>\r\n              </tr>\r\n            </table>\r\n          </td>\r\n        </tr>\r\n      </table>\r\n    </div>\r\n    `,\r\n  });\r\n};\r\n\r\nexport default sendRecoveryEmail;\r\n",
  "src\\infraestructure\\security\\rateLimit.ts": "// config/rateLimit.ts\r\nimport rateLimit from \"express-rate-limit\";\r\n\r\nexport const loginLimiter = rateLimit({\r\n  windowMs: 15 * 60 * 1000, // 15 minutos\r\n  max: 5,\r\n  message: \"Demasiados intentos. Intenta nuevamente en 15 minutos.\",\r\n  standardHeaders: true,\r\n  legacyHeaders: false,\r\n});\r\n",
  "src\\interfaces\\controllers\\auth\\auth.controller.ts": "import { Request, Response } from \"express\";\r\nimport * as authService from \"@/domain/services/auth/auth.service\";\r\nimport { userRepository } from \"@/infraestructure/db/user.repository\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\n// ‚úÖ REGISTRO\r\nexport const register = async (req: Request, res: Response) => {\r\n  try {\r\n    await authService.registerUser({ userRepository }, req.body);\r\n    res.status(201).json({\r\n      message: \"Registro exitoso. Revisa tu correo para confirmar tu cuenta.\",\r\n    });\r\n    logger.info(`‚úÖ Usuario registrado: ${req.body.email}`);\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Registro:\", error.message);\r\n    res.status(400).json({ message: error.message || \"Error al registrar\" });\r\n  }\r\n};\r\n\r\n// ‚úÖ LOGIN\r\nexport const login = async (req: Request, res: Response) => {\r\n  const { email, password } = req.body;\r\n\r\n  try {\r\n    const data = await authService.loginUser({ userRepository }, email, password);\r\n    res.json(data);\r\n    logger.info(`‚úÖ Login exitoso: ${email}`);\r\n  } catch (error: any) {\r\n    if (error.message === \"Debes confirmar tu cuenta\") {\r\n      res.status(401).json({\r\n        message: error.message,\r\n        tokenExpired: error.tokenExpired || false,\r\n      });\r\n    } else {\r\n      res.status(401).json({ message: error.message || \"Error al iniciar sesi√≥n\" });\r\n    }\r\n  }\r\n};\r\n\r\n// ‚úÖ LOGOUT (placeholder si usas JWT)\r\nexport const logout = async (_req: Request, res: Response) => {\r\n  res.json({ message: \"Sesi√≥n cerrada\" });\r\n};\r\n\r\n// ‚úÖ SOLICITAR RECUPERACI√ìN DE CONTRASE√ëA\r\nexport const sendRecovery = async (req: Request, res: Response) => {\r\n  const { email } = req.body;\r\n\r\n  try {\r\n    await authService.sendResetPassword({ userRepository }, email);\r\n    res.json({ message: \"Correo de recuperaci√≥n enviado.\" });\r\n    logger.info(`‚úÖ Correo de recuperaci√≥n enviado: ${email}`);\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Enviar recuperaci√≥n:\", error.message);\r\n    res.status(400).json({ message: error.message });\r\n  }\r\n};\r\n\r\n// ‚úÖ CAMBIAR CONTRASE√ëA\r\nexport const resetPassword = async (req: Request, res: Response) => {\r\n  const { token, password } = req.body;\r\n\r\n  try {\r\n    await authService.resetPassword({ userRepository }, token, password);\r\n    res.json({ message: \"Contrase√±a actualizada con √©xito.\" });\r\n    logger.info(`‚úÖ Clave actualizada con √©xito`);\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Reset password:\", error.message);\r\n    res.status(400).json({ message: error.message });\r\n  }\r\n};\r\n",
  "src\\interfaces\\controllers\\auth\\confirm.controller.ts": "import { Request, Response } from \"express\";\r\nimport {\r\n  confirmAccountService,\r\n  resendConfirmationService,\r\n} from \"@/domain/services/auth/confirm.service\";\r\nimport { userRepository } from \"@/infraestructure/db/user.repository\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\n// ‚úÖ CONFIRMAR USUARIO\r\nexport const confirmUser = async (req: Request, res: Response): Promise<void> => {\r\n  const { token } = req.params;\r\n  const { email } = req.query;\r\n\r\n  try {\r\n    const result = await confirmAccountService({ userRepository }, token, email as string | undefined);\r\n    res.status(result.code).json({ message: result.message });\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Error al confirmar:\", error);\r\n    res.status(500).json({ message: \"Error en el servidor\" });\r\n  }\r\n};\r\n\r\n// ‚úÖ REENVIAR CONFIRMACI√ìN\r\nexport const resendConfirmation = async (req: Request, res: Response): Promise<void> => {\r\n  const { email } = req.body;\r\n\r\n  try {\r\n    await resendConfirmationService({ userRepository }, email);\r\n    res.status(200).json({\r\n      message: \"Se envi√≥ un nuevo enlace de confirmaci√≥n a tu correo\",\r\n    });\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Error al reenviar confirmaci√≥n:\", error.message || error);\r\n    res.status(400).json({\r\n      message: error.message || \"Error al reenviar confirmaci√≥n\",\r\n    });\r\n  }\r\n};\r\n",
  "src\\interfaces\\controllers\\auth\\recover.controller.ts": "import { Request, Response } from \"express\";\r\nimport * as recoveryService from \"@/domain/services/auth/recovery.service\";\r\nimport { userRepository } from \"@/infraestructure/db/user.repository\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\n// ‚úÖ 1. Enviar correo de recuperaci√≥n\r\nexport const sendRecovery = async (req: Request, res: Response) => {\r\n  const { email } = req.body;\r\n\r\n  try {\r\n    await recoveryService.sendRecoveryService({ userRepository }, email);\r\n    res.json({ message: \"Correo de recuperaci√≥n enviado. Revisa tu bandeja.\" });\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Error en sendRecovery:\", error.message);\r\n    res\r\n      .status(error.status || 500)\r\n      .json({ message: error.message || \"Error del servidor\" });\r\n  }\r\n};\r\n\r\n// ‚úÖ 2. Verificar token\r\nexport const checkTokenStatus = async (req: Request, res: Response) => {\r\n  const { token } = req.body;\r\n\r\n  try {\r\n    const isValid = await recoveryService.checkTokenStatusService({ userRepository }, token);\r\n    res.json({ valid: isValid });\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Error en checkTokenStatus:\", error.message);\r\n    res.status(500).json({ message: \"Error al verificar token\" });\r\n  }\r\n};\r\n\r\n// ‚úÖ 3. Cambiar contrase√±a\r\nexport const resetPassword = async (req: Request, res: Response) => {\r\n  const { token } = req.params;\r\n  const { password } = req.body;\r\n\r\n  try {\r\n    await recoveryService.resetPasswordService({ userRepository }, token, password);\r\n    res.json({ message: \"Contrase√±a actualizada correctamente\" });\r\n  } catch (error: any) {\r\n    logger.error(\"‚ùå Error en resetPassword:\", error.message);\r\n    res.status(500).json({ message: \"Error al cambiar contrase√±a\" });\r\n  }\r\n};\r\n",
  "src\\interfaces\\controllers\\dashboard\\dashboard.controller.ts": "// backend/src/controllers/dashboard.controller.ts\r\nimport { Response } from \"express\";\r\nimport { AuthenticatedRequest } from \"@/types/express\";\r\n\r\nexport const getDashboard = async (\r\n  req: AuthenticatedRequest,\r\n  res: Response\r\n): Promise<void> => {\r\n  const user = req.user;\r\n\r\n  res.json({\r\n    message: `Hola ${user.name}, bienvenido al dashboard.`,\r\n    role: user.role,\r\n  });\r\n};\r\n",
  "src\\interfaces\\middlewares\\auth\\auth.middleware.ts": "import { Request, Response, NextFunction } from \"express\";\r\nimport { verifyToken, TokenPayload } from \"@/shared/security/jwt\";\r\nimport { AuthenticatedRequest } from \"@/types/express\";\r\n\r\nexport const authMiddleware = (\r\n  req: Request,\r\n  res: Response,\r\n  next: NextFunction\r\n): void => {\r\n  const authHeader = req.headers.authorization;\r\n\r\n  if (!authHeader || !authHeader.startsWith(\"Bearer \")) {\r\n    res.status(401).json({ message: \"Token no proporcionado\" });\r\n    return;\r\n  }\r\n\r\n  const token = authHeader.split(\" \")[1];\r\n\r\n  try {\r\n    const decoded = verifyToken(token) as TokenPayload;\r\n    (req as AuthenticatedRequest).user = decoded;\r\n    next();\r\n  } catch {\r\n    res.status(401).json({ message: \"Token inv√°lido o expirado\" });\r\n  }\r\n};\r\n",
  "src\\interfaces\\middlewares\\error\\errorHandler.middleware.ts": "// middlewares/errorHandler.middleware.ts\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\nconst errorHandler = (\r\n  err: any,\r\n  _req: Request,\r\n  res: Response,\r\n  _next: NextFunction\r\n) => {\r\n  logger.error(`‚ùå Error global: ${err.stack || err.message}`);\r\n  res\r\n    .status(err.status || 500)\r\n    .json({ message: err.message || \"Error interno del servidor\" });\r\n};\r\n\r\nexport default errorHandler;\r\n",
  "src\\interfaces\\middlewares\\error\\notFound.middleware.ts": "// middlewares/notFound.middleware.ts\r\nimport { Request, Response } from \"express\";\r\nimport logger from \"@/infraestructure/logger/logger\";\r\n\r\nconst notFound = (req: Request, res: Response) => {\r\n  logger.warn(`üö´ Ruta no encontrada: ${req.method} ${req.originalUrl}`);\r\n  res.status(404).json({ message: \"Ruta no encontrada\" });\r\n};\r\n\r\nexport default notFound;\r\n",
  "src\\interfaces\\middlewares\\role\\role.middleware.ts": "// role.middleware.ts\r\nimport { Response, NextFunction } from 'express';\r\nimport { AuthenticatedRequest } from '@/types/express'; // Solo importa esto si usas req.user\r\n\r\nexport const checkRole = (allowedRoles: string[]) => {\r\n  return (req: AuthenticatedRequest, res: Response, next: NextFunction): void => {\r\n    const user = req.user;\r\n\r\n    if (!user || !allowedRoles.includes(user.role)) {\r\n      res.status(403).json({ message: 'Acceso denegado: rol insuficiente' });\r\n      return;\r\n    }\r\n\r\n    next();\r\n  };\r\n};\r\n",
  "src\\interfaces\\middlewares\\sanitize\\sanitizeRequest.ts": "// middlewares/sanitizeRequest.ts\r\nimport { sanitize } from \"@/shared/sanitize\";\r\nimport { Request, Response, NextFunction } from \"express\";\r\n\r\nconst sanitizeObject = (obj: any) => {\r\n  for (const key in obj) {\r\n    if (typeof obj[key] === \"string\") {\r\n      obj[key] = sanitize(obj[key]);\r\n    } else if (typeof obj[key] === \"object\") {\r\n      sanitizeObject(obj[key]);\r\n    }\r\n  }\r\n};\r\n\r\nexport const sanitizeRequest = (\r\n  req: Request,\r\n  _res: Response,\r\n  next: NextFunction\r\n) => {\r\n  sanitizeObject(req.body);\r\n  sanitizeObject(req.query);\r\n  sanitizeObject(req.params);\r\n  next();\r\n};\r\n",
  "src\\interfaces\\middlewares\\validate\\validateInput.ts": "// middlewares/validateInput.ts\r\nimport { Request, Response, NextFunction } from \"express\";\r\nimport { ZodSchema } from \"zod\";\r\n\r\nexport const validate = (schema: ZodSchema) => async (\r\n    req: Request,\r\n    res: Response,\r\n    next: NextFunction\r\n) => {\r\n    try {\r\n        req.body = await schema.parseAsync(req.body);\r\n        next();\r\n    } catch (err: any) {\r\n        res.status(400).json({ errors: err.errors });\r\n    }\r\n};\r\n",
  "src\\interfaces\\routes\\auth\\auth.routes.ts": "// src/interfaces/routes/auth/auth.routes.ts\r\nimport { Router } from \"express\";\r\nimport {\r\n  login,\r\n  register,\r\n  logout,\r\n} from \"@/interfaces/controllers/auth/auth.controller\";\r\nimport {\r\n  confirmUser,\r\n  resendConfirmation,\r\n} from \"@/interfaces/controllers/auth/confirm.controller\";\r\nimport {\r\n  sendRecovery,\r\n  checkTokenStatus,\r\n  resetPassword,\r\n} from \"@/interfaces/controllers/auth/recover.controller\";\r\n\r\nimport { authMiddleware } from \"@/interfaces/middlewares/auth/auth.middleware\";\r\nimport { checkRole } from \"@/interfaces/middlewares/role/role.middleware\";\r\nimport { getDashboard } from \"@/interfaces/controllers/dashboard/dashboard.controller\";\r\nimport { validate } from \"@/interfaces/middlewares/validate/validateInput\";\r\nimport { registerSchema, loginSchema } from \"@/shared/validations/auth.schema\";\r\nimport { loginLimiter } from \"@/infraestructure/security/rateLimit\";\r\nimport { AuthenticatedRequest } from \"@/types/express\";\r\n\r\nconst router = Router();\r\n\r\n// ‚úÖ Registro y autenticaci√≥n\r\nrouter.post(\"/register\", validate(registerSchema), register);\r\nrouter.post(\"/login\", loginLimiter, validate(loginSchema), login);\r\nrouter.post(\"/logout\", logout);\r\n\r\n// ‚úÖ Confirmaci√≥n de cuenta\r\nrouter.get(\"/confirm/:token\", confirmUser);\r\nrouter.post(\"/resend-confirmation\", loginLimiter, resendConfirmation);\r\n\r\n// ‚úÖ Recuperaci√≥n de contrase√±a\r\nrouter.post(\"/send-recovery\", loginLimiter, sendRecovery);\r\nrouter.post(\"/reset-password\", resetPassword); // desde el frontend con token incluido en el body\r\nrouter.post(\"/reset-password/:token\", resetPassword); // v√≠a URL directa con token\r\nrouter.post(\"/check-token-status\", checkTokenStatus);\r\n\r\n// ‚úÖ Ruta protegida de prueba\r\nrouter.get(\"/dashboard\", authMiddleware, (req, res) =>\r\n  getDashboard(req as AuthenticatedRequest, res)\r\n);\r\n\r\nexport default router;\r\n",
  "src\\interfaces\\routes\\dashboard\\dashboard.routes.ts": "import { Router } from \"express\";\r\nimport { getDashboard } from \"@/interfaces/controllers/dashboard/dashboard.controller\";\r\nimport { authMiddleware } from \"@/interfaces/middlewares/auth/auth.middleware\";\r\nimport { AuthenticatedRequest } from \"@/types/express\";\r\n\r\nconst router = Router();\r\n\r\nrouter.get(\"/dashboard\", authMiddleware, (req, res) =>\r\n  getDashboard(req as AuthenticatedRequest, res)\r\n);\r\n\r\nexport default router;\r\n",
  "src\\shared\\hash.ts": "// utils/hash.ts\r\nimport bcrypt from \"bcryptjs\";\r\n\r\nexport const hashPassword = async (password: string) => await bcrypt.hash(password, 10);\r\nexport const verifyPassword = async (plain: string, hashed: string) => await bcrypt.compare(plain, hashed);\r\n",
  "src\\shared\\sanitize.ts": "// src/utils/sanitize.ts\r\nimport { JSDOM } from 'jsdom';\r\nimport createDOMPurify from 'dompurify';\r\n\r\nconst window = new JSDOM('').window;\r\nconst DOMPurify = createDOMPurify(window);\r\n\r\nexport const sanitize = (input: string): string => {\r\n  return DOMPurify.sanitize(input);\r\n};\r\n",
  "src\\shared\\security\\jwt.ts": "// jwt.ts\r\nimport jwt, { JwtPayload } from 'jsonwebtoken';\r\nimport dotenv from 'dotenv';\r\n\r\ndotenv.config();\r\n\r\nconst JWT_SECRET = process.env.JWT_SECRET || 'supersecret';\r\nconst JWT_EXPIRES_IN = '7d';\r\n\r\nexport type RoleName = 'admin' | 'client' | 'moderator' | 'superadmin'; // extensible\r\n\r\nexport interface TokenPayload {\r\n  id: number;\r\n  email: string;\r\n  name: string;\r\n  role: RoleName;\r\n}\r\n\r\nexport const generateToken = (payload: TokenPayload): string => {\r\n  return jwt.sign(payload, JWT_SECRET, { expiresIn: JWT_EXPIRES_IN });\r\n};\r\n\r\nexport const verifyToken = (token: string): TokenPayload => {\r\n  return jwt.verify(token, JWT_SECRET) as TokenPayload;\r\n};\r\n",
  "src\\shared\\tokens.ts": "// utils/tokens.ts\r\nimport crypto from \"crypto\";\r\n\r\nexport const generateToken = (length = 32): string => {\r\n  return crypto.randomBytes(length).toString(\"hex\");\r\n};\r\n",
  "src\\shared\\validations\\auth.schema.ts": "// validations/auth.schema.ts\r\nimport { z } from \"zod\";\r\n\r\nexport const loginSchema = z.object({\r\n  email: z.string().email(),\r\n  password: z.string().min(8),\r\n});\r\n\r\nexport const registerSchema = z\r\n  .object({\r\n    name: z.string().min(2),\r\n    email: z.string().email(),\r\n    phone: z.string().regex(/^\\d{10}$/),\r\n    password: z.string().min(8),\r\n    confirmPassword: z.string(),\r\n  })\r\n  .refine((data) => data.password === data.confirmPassword, {\r\n    message: \"Las contrase√±as no coinciden\",\r\n    path: [\"confirmPassword\"],\r\n  });\r\n",
  "src\\shared\\validations\\validators.ts": "import bcrypt from \"bcryptjs\";\r\n\r\n// Validaci√≥n de email\r\nexport const validateEmail = (email: string) => {\r\n  const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\r\n  if (!emailRegex.test(email)) {\r\n    throw new Error(\"Correo electr√≥nico inv√°lido.\");\r\n  }\r\n};\r\n\r\n// Solo valida que sea fuerte (para el registro)\r\nexport const validateNewPassword = (password: string): void => {\r\n  const minLength = 8;\r\n  const hasUpperCase = /[A-Z]/.test(password);\r\n  const hasLowerCase = /[a-z]/.test(password);\r\n  const hasNumber = /\\d/.test(password);\r\n  const hasSpecialChar = /[!@#$%^&*(),.?\":{}|<>]/.test(password);\r\n\r\n  if (password.length < minLength)\r\n    throw new Error(\"La contrase√±a debe tener al menos 8 caracteres.\");\r\n\r\n  if (!hasUpperCase)\r\n    throw new Error(\"La contrase√±a debe tener al menos una letra may√∫scula.\");\r\n\r\n  if (!hasLowerCase)\r\n    throw new Error(\"La contrase√±a debe tener al menos una letra min√∫scula.\");\r\n\r\n  if (!hasNumber)\r\n    throw new Error(\"La contrase√±a debe incluir al menos un n√∫mero.\");\r\n\r\n  if (!hasSpecialChar)\r\n    throw new Error(\"La contrase√±a debe incluir un car√°cter especial.\");\r\n};\r\n\r\n// Valida que no sea igual a la anterior ni al correo\r\nexport const validatePasswordChange = async (\r\n  newPassword: string,\r\n  email: string,\r\n  currentPasswordHash: string\r\n): Promise<void> => {\r\n  validateNewPassword(newPassword);\r\n\r\n  if (newPassword === email)\r\n    throw new Error(\"La contrase√±a no debe ser igual al correo.\");\r\n\r\n  const isSameAsOld = await bcrypt.compare(newPassword, currentPasswordHash);\r\n  if (isSameAsOld)\r\n    throw new Error(\"La nueva contrase√±a no puede ser igual a la anterior.\");\r\n};\r\n\r\n",
  "src\\types\\express.d.ts": "// src/types/express.d.ts\r\nimport { Request } from \"express\";\r\nimport { TokenPayload } from \"../config/jwt\";\r\n\r\nexport interface AuthenticatedRequest extends Request {\r\n  user?: TokenPayload;\r\n}\r\n"
}